import JSZip from 'jszip'
import { saveAs } from 'file-saver'

export interface ProjectFile {
  name: string
  content: string
}

export async function downloadProjectAsZip(
  files: ProjectFile[],
  projectName: string = 'v0-project'
) {
  const zip = new JSZip()

  // Add each file to the zip
  files.forEach((file) => {
    zip.file(file.name, file.content)
  })

  // Add package.json if not present
  const hasPackageJson = files.some(f => f.name === 'package.json')
  if (!hasPackageJson) {
    const packageJson = {
      name: projectName.toLowerCase().replace(/\s+/g, '-'),
      version: '1.0.0',
      private: true,
      scripts: {
        dev: 'next dev',
        build: 'next build',
        start: 'next start',
        lint: 'next lint'
      },
      dependencies: {
        'next': '^14.0.0',
        'react': '^18.0.0',
        'react-dom': '^18.0.0',
        'tailwindcss': '^3.0.0'
      },
      devDependencies: {
        '@types/node': '^20.0.0',
        '@types/react': '^18.0.0',
        '@types/react-dom': '^18.0.0',
        'typescript': '^5.0.0'
      }
    }
    zip.file('package.json', JSON.stringify(packageJson, null, 2))
  }

  // Add configuration files
  addConfigFiles(zip, files, projectName)

  try {
    // Generate the zip file
    const blob = await zip.generateAsync({ type: 'blob' })
    
    // Download the file
    saveAs(blob, `${projectName}.zip`)
    
    return true
  } catch (error) {
    console.error('Error creating ZIP file:', error)
    return false
  }
}

function addConfigFiles(zip: JSZip, files: ProjectFile[], projectName: string) {
  // Add README.md if not present
  const hasReadme = files.some(f => f.name.toLowerCase().includes('readme'))
  if (!hasReadme) {
    const readme = `# ${projectName}

This project was generated by v0.

## Getting Started

First, install the dependencies:

\`\`\`bash
npm install
\`\`\`

Then, run the development server:

\`\`\`bash
npm run dev
\`\`\`

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.
`
    zip.file('README.md', readme)
  }

  // Add Next.js config
  const hasNextConfig = files.some(f => f.name.includes('next.config'))
  if (!hasNextConfig) {
    const nextConfig = `/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true,
  },
}

module.exports = nextConfig`
    zip.file('next.config.js', nextConfig)
  }

  // Add TypeScript config
  const hasTsConfig = files.some(f => f.name.includes('tsconfig'))
  if (!hasTsConfig) {
    const tsConfig = {
      compilerOptions: {
        target: "es5",
        lib: ["dom", "dom.iterable", "es6"],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        noEmit: true,
        esModuleInterop: true,
        module: "esnext",
        moduleResolution: "node",
        jsx: "preserve",
        incremental: true,
        paths: {
          "@/*": ["./*"]
        }
      },
      include: ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
      exclude: ["node_modules"]
    }
    zip.file('tsconfig.json', JSON.stringify(tsConfig, null, 2))
  }
}

export function extractFilesFromChat(chat: any): ProjectFile[] {
  const files: ProjectFile[] = []
  
  if (!chat?.messages) return files

  // Look for files in the latest version first
  if (chat.latestVersion?.files) {
    chat.latestVersion.files.forEach((file: any) => {
      files.push({
        name: file.name,
        content: file.content
      })
    })
  }

  // Look for files in messages experimental_content
  if (files.length === 0 && chat.messages) {
    chat.messages.forEach((message: any) => {
      // Check experimental_content structure
      if (message.experimental_content) {
        const content = message.experimental_content
        
        // Look for files array
        if (content.files && Array.isArray(content.files)) {
          content.files.forEach((file: any) => {
            files.push({
              name: file.name || 'index.tsx',
              content: file.content || file.code || ''
            })
          })
        }
        
        // Look for code blocks or components
        if (content.parts && Array.isArray(content.parts)) {
          content.parts.forEach((part: any, index: number) => {
            if (part.type === 'code' && part.content) {
              const fileName = part.fileName || `component-${index + 1}.tsx`
              files.push({
                name: fileName,
                content: part.content
              })
            }
          })
        }
        
        // Look for single code block
        if (content.code && typeof content.code === 'string') {
          files.push({
            name: 'index.tsx',
            content: content.code
          })
        }
      }
      
      // Fallback: extract from plain content if it looks like code
      if (files.length === 0 && message.content && typeof message.content === 'string') {
        const content = message.content
        if (content.includes('export default') || content.includes('import React')) {
          files.push({
            name: 'index.tsx',
            content: content
          })
        }
      }
    })
  }

  // Add default files if none found but we have a demo URL
  if (files.length === 0 && chat.demo) {
    files.push({
      name: 'index.tsx',
      content: `// Generated by v0
// Demo URL: ${chat.demo}

export default function Component() {
  return (
    <div className="p-4">
      <h1>Generated Component</h1>
      <p>Visit the demo URL to see the actual component.</p>
      <a href="${chat.demo}" target="_blank" rel="noopener noreferrer">
        View Demo
      </a>
    </div>
  );
}`
    })
  }

  return files
}
